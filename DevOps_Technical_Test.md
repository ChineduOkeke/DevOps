### **DevOps Test: CI Pipeline, AWS Infrastructure, and EKS Deployment**

### **Objective:**
1.Fork the provided GitHub repository to your own GitHub account.
2.should create a continuous integration (CI) pipeline using CircleCI or any other CI/CD tool of your choice. 
3.provision AWS infrastructure using Terraform, 
4.deploy the application to AWS EKS from your GitHub repository.

---

### **Test Steps:**

### **1. Setting Up the Pipeline**

- **Task**: Configure a  pipeline for the application.:
    - **Triggers** on every push or pull request to the `main` branch.
    - **Builds** the application code using a Docker image.
    - **Runs Tests** to ensure the code is functioning as expected.
    - **Builds** a Docker image of the application and pushes it to a container registry (e.g., AWS ECR or Docker Hub).
    - **GithuB Version**: Impelement GitHub version control for releases
- **Pipeline Configuration**:
    - Create a necessary  files for example in case of CircleCi`.circleci/config.yml` file in the root of the repository.
    - Build the Docker image.
    - Integrate AWS credentials securely to push the Docker image to the container registry(ECR).
- **Evaluation Criteria**:
    - Correct configuration of the  pipeline.
    - Successful Docker image build and push.
    - Use of environment variables for sensitive information.

### **2. Provisioning AWS Infrastructure with Terraform**

- **Task**: Use Terraform to create the necessary AWS infrastructure:
    - An EKS cluster with the required IAM roles, node groups, and networking (VPC, subnets, security groups).
    - An S3 bucket for storing Terraform state files with state locking enabled using DynamoDB (optional).
    - A dedicated namespace in the EKS cluster for deploying the application.
- **Requirements**:
    - Structure Terraform code into modules for reusability and clarity.
    - Ensure that the EKS cluster is accessible and ready for application deployment.
- **Evaluation Criteria**:
    - Correct and efficient Terraform code.
    - Modular Terraform setup.
    - Proper handling of Terraform state and security considerations.

### **3. Deploying the Application to AWS EKS and Exposing via Load Balancer**

- **Task**: Extend the pipeline to deploy the application to the EKS cluster:
    - **Kubernetes Deployment**: Use Kubernetes manifest files (YAML) to define the deployment and service for the application.
    - **Service Type**: Create a Kubernetes `Service` of type `LoadBalancer` to expose the application externally.
    - **Accessing the Application**: The application should be accessible via the DNS name automatically generated by AWS for the Load Balancer.
- **Deployment Configuration**:
    - Use `kubectl` in the  pipeline to apply the Kubernetes manifests to the EKS cluster.
    - Store sensitive data like API keys or database credentials using Kubernetes secrets or AWS Secrets Manager.
- **Evaluation Criteria**:
    - Successful deployment of the application to the EKS cluster.
    - Kubernetes best practices such as proper use of resources, probes, and secrets.
    - Efficient and scalable deployment strategy.

  
### **Test Environment:**

- **Tools**:
    - CI/CD account linked to the GitHub repository.
    - AWS credentials with sufficient permissions for EKS and other AWS services.
    - Access to a Docker registry (AWS ECR or Docker Hub).
- **Pre-installed Software**:
    - Terraform, AWS CLI, `kubectl`, Docker.
- **Documentation Access**:
    - Provide access to CI/CD, Terraform, AWS, and Kubernetes documentation.


### **Bonus Points:**

- **Terraform Best Practices**: Implement remote state locking, use of AWS IAM roles, and advanced networking configurations.
- **Kubernetes Enhancements**: Implement blue/green deployment strategies, use Helm for managing Kubernetes resources, or set up advanced monitoring.

